<!doctype html><html><head><meta charset=utf-8><title>Assembly RISC-V &ndash; Michele Schimd
</title><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://cdn.jsdelivr.net/npm/bootswatch@4.5.2/dist/spacelab/bootstrap.min.css rel=stylesheet><link href=https://profschimd.github.io/css/syntax.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css><script src=https://code.jquery.com/jquery-3.4.1.slim.min.js integrity=sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n crossorigin=anonymous></script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class="d-flex flex-column min-vh-100"><header><nav class="p-1 navbar navbar-expand-lg navbar-dark bg-primary"><div class=container><a class=navbar-brand rel=author href=https://profschimd.github.io/>Michele Schimd</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav ml-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-expanded=false>Materie</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a href=https://profschimd.github.io/materie/inf/ class=dropdown-item>Informatica</a></li><li><a href=https://profschimd.github.io/materie/sr/ class=dropdown-item>SR</a></li><li><a href=https://profschimd.github.io/materie/tpsit/ class=dropdown-item>TPSIT</a></li><li><a href=https://profschimd.github.io/materie/gpoi/ class=dropdown-item>GPOI</a></li><li><a href=https://profschimd.github.io/materie/ec/ class=dropdown-item>EC</a></li><li><a href=https://profschimd.github.io/materie/python/ class=dropdown-item>Python</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-expanded=false>Classi</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a href=https://profschimd.github.io/classi/3ic/ class=dropdown-item>3IC</a></li><li><a href=https://profschimd.github.io/classi/4ic/ class=dropdown-item>4IC</a></li><li><a href=https://profschimd.github.io/classi/4ia/ class=dropdown-item>5IA</a></li><li><a href=https://profschimd.github.io/classi/5ic/ class=dropdown-item>5IC</a></li><li><a href=https://profschimd.github.io/classi/anni-passati/ class=dropdown-item>Anni precedenti</a></li></ul></li><li class=nav-item><a class=nav-link href=https://profschimd.github.io/about/ role=button><i class="bi bi-info-circle"></i></a></li></ul></div></div></nav></header><div class="p-4 bg-primary" style="background-size:cover;background-position:50%;background-image:linear-gradient(to bottom,rgba(0,0,0,.3) 0%,rgba(0,0,0,.6) 100%),url(https://profschimd.github.io/img/zuccante_it.jpeg)"><div class=container><h1 class="display-4 text-white">Assembly RISC-V</h1></div></div><div class=bg-light><nav aria-label="breadcrumb mt-0"><div class=container><ol class="breadcrumb py-0 my-1 small"><li class=breadcrumb-item><a href=https://profschimd.github.io/>Home</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/>Materie</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/sr/>Sistemi e Reti</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/sr/3/>Sistemi e Reti - Terzo Anno</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/sr/3/03-assembly/>Assembly</a></li><li class="breadcrumb-item active" aria-current=page><a href=https://profschimd.github.io/materie/sr/3/03-assembly/01-riscv/>Assembly RISC-V</a></li></ol></nav></div><div class="container py-5"><main><div class=row><div class=col-10><aside><nav id=TableOfContents><ul><li><a href=#basi-del-linguaggio-assembly-risc-v>Basi del linguaggio assembly RISC-V</a></li><li><a href=#sintassi-delle-istruzioni>Sintassi delle istruzioni</a></li><li><a href=#istruzioni-risc-v>Istruzioni RISC-V</a><ul><li><a href=#istruzioni-aritmetico-logiche>Istruzioni aritmetico-logiche</a></li><li><a href=#istruzioni-load-e-store>Istruzioni Load e Store</a></li><li><a href=#istruzioni-di-branch-e-di-salto>Istruzioni di branch e di salto</a></li><li><a href=#esempi-2>Esempi</a></li></ul></li><li><a href=#link>Link</a></li></ul></nav></aside></div><div class=col-2></div></div><article><div class=container style=text-align:justify><h2 id=basi-del-linguaggio-assembly-risc-v>Basi del linguaggio assembly RISC-V</h2><p>RISC-V è un linguaggio <strong>assembly di tipo RISC</strong> ed è basato sul principio che <em>tutte le istruzioni hanno la stessa dimensione</em>: 32 o 64 bit. Questo vincolo su RISC-V rende la progettazione del circuito di decode per RISC-V più semplice rispetto ad altri linguaggi in cui ci possono istruzioni di diversa dimensione (ad esempio l&rsquo;assembly x86).</p><p>Altra caratteristica di RISC-V è il fatto che l&rsquo;<strong>architettura è ti tipo load-store</strong> che significa che gli operandi devono tutti trovarsi nei registri prima si possano fare operazioni aritmetico-logiche su di essi. Anche in questo caso la progettazione del circuito interno della CPU ne risulta molto semplificato.</p><h2 id=sintassi-delle-istruzioni>Sintassi delle istruzioni</h2><p>Il formato delle istruzioni RISC-V a 32 bit comprende diverse modi di rappresentare le istruzioni utilizzando i 32 bit. Ci limitiamo qui a vedere i principali formati che sono 6.</p><ol><li><strong>R</strong>egistry</li><li><strong>I</strong>mmediate</li><li><strong>U</strong>pper Immediate</li><li><strong>S</strong>tore</li><li><strong>B</strong>ranch</li><li><strong>J</strong>ump
Nella figura seguente possiamo vedere come ogni singolo di questi formati suddivida i 32 bit in modo da indicare:</li></ol><ul><li><code>opcode</code>: indica di che istruzione si tratta</li><li><code>funct3</code> e <code>funct</code>: ulteriori indicazione sul tipo di istruzione</li><li><code>rd</code>: registro di destinazione per i risultati</li><li><code>rs1</code> e <code>rs2</code>: registri per gli operandi</li><li><code>imm</code>: operandi immediati, vale a dire valori numerici costanti.</li></ul><p><img src=img/formato_istruzioni_riscv.png alt="Schema di formato delle istruzioni RISC-V"></p><h2 id=istruzioni-risc-v>Istruzioni RISC-V</h2><p>Le operazioni basilari presenti nell&rsquo;<a src=https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/ target=_blank>interpret RISC-V</a> online sono le seguenti:
Arithmetics: <code>ADD</code>, <code>ADDI</code>, <code>SUB</code>
Logical: <code>AND</code>, <code>ANDI</code>, <code>OR</code>, <code>ORI</code>, <code>XOR</code>, <code>XORI</code>
Sets: <code>SLT</code>, <code>SLTI</code>, <code>SLTU</code>, <code>SLTIU</code>
Shifts: <code>SRA</code>, <code>SRAI</code>, <code>SRL</code>, <code>SRLI</code>, <code>SLL</code>, <code>SLLI</code>
Memory: <code>LW</code>, <code>SW</code>, <code>LB</code>, <code>SB</code>
PC: <code>LUI</code>, <code>AUIPC</code>
Jumps: <code>JAL</code>, <code>JALR</code>
Branches: <code>BEQ</code>, <code>BNE</code>, <code>BLT</code>, <code>BGE</code>, <code>BLTU</code>, <code>BGEU</code>
È importante sapere che queste <strong>non sono tutte le operazioni del linguaggio RISC-V</strong>.</p><h6 class=no_toc>Un programma RISC-V</h6>Il seguente programma calcola la somma 1 + 2 + 3 + ... + 7 e mette il risultato nella cella di memoria di indirizzo 0.<div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>ADDI</span> <span class=nv>x11</span><span class=p>,</span> <span class=nv>x0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nf>ADDI</span> <span class=nv>x10</span><span class=p>,</span> <span class=nv>x0</span><span class=p>,</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=nl>.loop:</span>
</span></span><span class=line><span class=cl><span class=nf>ADD</span> <span class=nv>x11</span><span class=p>,</span> <span class=nv>x11</span><span class=p>,</span> <span class=nv>x10</span>
</span></span><span class=line><span class=cl><span class=nf>ADDI</span> <span class=nv>x10</span><span class=p>,</span> <span class=nv>x10</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nf>BNE</span> <span class=nv>x10</span><span class=p>,</span> <span class=nv>x0</span><span class=p>,</span> <span class=nv>.loop</span>
</span></span><span class=line><span class=cl><span class=nf>SW</span> <span class=nv>x11</span><span class=p>,</span> <span class=mi>0</span><span class=p>(</span><span class=nv>zero</span><span class=p>)</span>
</span></span></code></pre></div><p>Vediamo cosa fa ogni singola istruzione del programma.</p><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-pencil-square"></i> Esercizio</strong></h5><p>Scrivere un programma che fa la somma dei primi n numeri leggendo n dalla cella 0 della memoria e che mette il risultato nella cella 1 della memoria.</p></div><h3 id=istruzioni-aritmetico-logiche>Istruzioni aritmetico-logiche</h3><p>Le istruzioni aritmetico-logiche che consideriamo sono le seguenti.</p><ul><li>Addizione <code>ADD</code> e sottrazione <code>SUB</code></li><li>Operazioni logiche <code>AND</code>, <code>OR</code> e <code>XOR</code></li><li>Shift aritmetico <code>SRA</code>, shift logico sinistro <code>SLL</code> e shift logico destro <code>SRL</code></li></ul><p>Ognuna di queste istruzione ha lo stesso formato (<em>R-type instructions</em>)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>OPER</span> <span class=nv>rd</span><span class=p>,</span> <span class=nv>rs1</span><span class=p>,</span> <span class=nv>rs2</span>
</span></span></code></pre></div><ul><li><code>OPER</code> è il codice dell&rsquo;operazione (es. <code>ADD</code>, <code>AND</code>, &mldr;);</li><li><code>rd</code> è il registro di destinazione, cioè il registro nel quale verrà scritto il risultato finale;</li><li><code>rs1</code> e <code>rs2</code> sono i registri sorgente dai quali vengono presi gli <em>operandi</em>.</li></ul><p>Per ognuna delle operazioni aritmetico-logiche sopra elencate, esiste una versione <em>immediate</em> che, anziché avere il secondo registro sorgente <code>rs2</code>, ha un valore numerico costante a 12 bit.</p><h4 id=esempi>Esempi</h4><ul><li><p>Sommare i valori in <code>x10</code> e in <code>x11</code> mettendo il risultato in <code>x12</code></p><pre><code>  ADD x12, x10, x11
</code></pre></li><li><p>Mettere il valore <code>42</code> nel registro <code>x15</code> (aggiunge <code>x0=0</code> a <code>42</code> e mettere il risultato in <code>x15</code>)</p><pre><code>  ADDI x15, x0, 42
</code></pre></li><li><p>Fare la differenza tra <code>x10-x9</code> mettendo il risultato in <code>x10</code></p><pre><code>  SUB x10, x10, x9
</code></pre></li><li><p>Calcolare il resto della divisione per due di <code>x2</code> mettendo il risultato in <code>x3</code> (tale resto è proprio
il valore del <em>bit meno significativo</em>)</p><pre><code>  ANDI x3, x2, 1
</code></pre></li><li><p>Moltiplicare per <code>4</code> il valore di <code>x22</code> e mettere il risultato in <code>x30</code> (per moltiplicare per 4 basta
<em>shiftare</em> a sinistra il valore di un due bit)</p><pre><code>  SLLI x30, x22, 2
</code></pre></li></ul><h3 id=istruzioni-load-e-store>Istruzioni Load e Store</h3><p>Ogni programma utilizza la memoria RAM per depositare i risultati calcolati, per leggere input e per scrivere output, è quindi fondamentale che un linguaggio assembly contenga istruzione per la lettura e la scrittura della memoria. In RISC-V queste di istruzioni vengono dette <strong>load</strong> e <strong>store</strong>.</p><p>La sintassi di queste istruzioni prevede due versioni: una per spostare da e per la memoria byte, l&rsquo;altra per spostare parole (<em>word</em>).
Esistono, quindi, quattro tipi di istruzioni di accesso alla memoria: due di caricamento dalla memoria ad un registro <code>rd</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>LB</span> <span class=nv>rd</span><span class=p>,</span> <span class=nv>MEM</span>
</span></span><span class=line><span class=cl><span class=nf>LW</span> <span class=nv>rd</span><span class=p>,</span> <span class=nv>MEM</span>
</span></span></code></pre></div><p>e due per il salvataggi in memoria del contenuto del registro <code>rd</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>SB</span> <span class=nv>rd</span><span class=p>,</span> <span class=nv>MEM</span>
</span></span><span class=line><span class=cl><span class=nf>SW</span> <span class=nv>rd</span><span class=p>,</span> <span class=nv>MEM</span>
</span></span></code></pre></div><p>Come è facile capire, le due versioni <code>B</code> e <code>W</code> si usano per spostare byte o word. Mentre il primo parametro, da noi indicato con <code>rd</code>,
serve ad indicare il registro nella CPU da cui prendere (store) a su cui mettere (load) il contenuto della memoria, l&rsquo;indirizzo di memoria, che
noi abbiamo indicato con <code>MEM</code>, deve essere calcolato utilizzando opportune tecniche di <strong>indirizzamento della memoria</strong> che discutiamo nel
seguito.</p><h4 id=indirizzamento-della-memoria>Indirizzamento della memoria</h4><p>Le istruzioni load e store necessitano di una regola per indicare quale cella di memoria deve essere letta o scritta. La prima cosa che viene in mente è usare istruzioni in cui l&rsquo;indirizzo viene dato direttamente come numero (es. <code>1234</code> per indicare la cella di memoria di indirizzo <code>1234</code>). Istruzioni di questo tipo, però, permettono di indicare un numero di celle di memoria che è limitato dal numero di bit che si possono usare nell&rsquo;istruzione per l&rsquo;<em>immediate</em>. Ad esempio in una <em>I-instruction</em> in cui l&rsquo;immediate è di 12 bit, si possono solo indicare solo le celle con indirizzo tra 0 e 4095, questo permetterebbe di scrivere programmi che usano al massimo 4 KByte di memoria dati, piuttosto limitato per qualsiasi programma oggi giorno.
Per poter usare più di 4096 celle di memoria, RISC-V utilizza la tecnica del <strong class=text-danger>registro base</strong>. In pratica l&rsquo;indirizzo viene dato indicando un <strong>indirizzo di base</strong> su un registro e un <strong>offset</strong> numerico. Per esempio si può indicare un offset di 430 rispetto al registro base <code>x11</code>. Se in <code>x11</code>, per esempio, c&rsquo;è il numero 8500, allora andremmo in questo modo ad utilizzare la cella 8500 + 430 = 8930. Come si vede è possibile in questo modo utilizzare memoria molto grandi, basta impostare il valore del registro base.</p><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-journal-code"></i> Esempio</strong></h5><p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>ADDI</span> <span class=nv>x10</span><span class=p>,</span> <span class=nv>x0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nf>SLLI</span> <span class=nv>x10</span><span class=p>,</span> <span class=nv>x10</span><span class=p>,</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl><span class=nf>ADDI</span> <span class=nv>x11</span><span class=p>,</span> <span class=nv>x0</span><span class=p>,</span> <span class=mi>123</span>
</span></span><span class=line><span class=cl><span class=nf>SB</span> <span class=nv>x11</span><span class=p>,</span> <span class=mi>2</span><span class=p>(</span><span class=nv>x10</span><span class=p>)</span>
</span></span></code></pre></div><p>Le prime due istruzioni fanno si che in x10 finisca il numero <code>2^20 = 0x100000</code>, la terza istruzione mette il numero <code>123</code> (decimale) in x11 ed infine la quarta istruzione carica il contenuto di <code>x11</code> (che è <code>123</code>) nella cella di indirizzo <code>2 + x10</code>, siccome x10 contiene il numero <code>0x100000</code> (esadecimale), la cella che verrà scritta è quella di indirizzo <code>0x100002</code> (esadecimale). Siamo quindi riusciti a scrivere in una cella il cui indirizzo (circa un milione) è molto più grande del più grande immediate (circa <code>4000</code>), questo non sarebbe stato possibile senza la tecnica del registro base.</p></p></div><h4 id=esempi-1>Esempi</h4><ul><li><p>Caricare in <code>x10</code> il contenuto del <em>byte</em> memoria all&rsquo;indirizzo <code>128</code></p><pre><code>  LB x10, 128(x0)
</code></pre></li><li><p>Caricare in <code>x10</code> il contenuto della <em>parola</em> di memoria all&rsquo;indirizzo <code>128</code></p><pre><code>  LW x10, 128(x0)
</code></pre></li><li><p>Salvare nella parola di memoria all&rsquo;indirizzo <code>80</code> il valore <code>17</code> (utilizzando il registro <code>x20</code>)</p><pre><code>  ADDI x20, x0, 17
  SW x20, 80(x0)
</code></pre></li><li><p>Salvare nel byte di memoria all&rsquo;indirizzo contenuto in <code>x10</code> il valore contenuto nel registro <code>x15</code></p><pre><code>  SB x15, 0(x10)
</code></pre></li></ul><h3 id=istruzioni-di-branch-e-di-salto>Istruzioni di branch e di salto</h3><p>Non si potrebbero scrivere programmi interessanti in qualsiasi linguaggio di programmazione senza istruzioni di condizione come l&rsquo;istruzione if o cicli come while. Lo stesso vale per programmi in linguaggio assembly in cui condizioni e cicli si fanno utilizzando istruzioni di salto. Queste istruzioni permettono di &ldquo;saltare&rdquo; ad una qualsiasi istruzione purché questa si possa identificare, per fare questo di usano delle etichette associate a quelle istruzioni che si vogliono raggiungere a seguito di un salto. Le etichette non sono altro che dei nomi che vengono date alle istruzioni, in pratica questi nomi indicano il numero dell&rsquo;istruzione (indirizzo di memoria dove l&rsquo;istruzione si trova), ovviamente le etichette sono più facili da ricordare dei numeri o degli indirizzi di memoria.</p><p>Le operazioni più importanti di salto sono quelle di salto condizionato cioè di salto nel caso in cui si verifica una certa condizione, in RISC-V queste istruzioni vengono anche chiamate istruzioni di branch. Tutti gli assembly contengono anche istruzioni si salto non condizionato che in RISC-V vengono chiamate jump.</p><p>Le istruzioni si salto condizionato in RISC-V sono</p><ul><li><code>BEQ</code> <strong>B</strong>ranch in <strong>EQ</strong>ual</li><li><code>BNE</code> <strong>B</strong>ranch if <strong>N</strong>ot <strong>E</strong>qual</li><li><code>BLT</code> <strong>B</strong>ranch if <strong>L</strong>ess <strong>T</strong>han</li><li><code>BGE</code> <strong>B</strong>ranch if <strong>G</strong>reater than or <strong>E</strong>qual</li><li><code>BLTU</code> <strong>B</strong>ranch if <strong>L</strong>ess <strong>T</strong>han <strong>U</strong>nsigned</li><li><code>BGEU</code> <strong>B</strong>ranch if <strong>G</strong>reater than or <strong>E</strong>qual <strong>U</strong>nsigned</li></ul><div class=row><div class=col-6></div><div class=col-6><div class=mxgraph style="max-width:100%;border:1px solid transparent" data-mxgraph='{"highlight":"#0000ff","nav":true,"resize":true,"toolbar":"zoom layers tags lightbox","edit":"_blank","xml":"<mxfile host=\"app.diagrams.net\" modified=\"2021-12-21T17:34:51.879Z\" agent=\"5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\" etag=\"HYuwEEOLAX1umOBFDlCZ\" version=\"15.9.6\" type=\"google\"><diagram id=\"mH412ocPkDbS9YASaeq8\" name=\"Page-1\">7Zrdb5swEMD/lj1E2h5aGRNI8tgkbbeHfWiZ1G0vkwsusergzDgN2V8/G2w+YpKuWgPLUioVfDbH4d/d+YD03MkiveZoOX/PQkx7EIRpz532IPT6jvyvBJtcAH03F0SchLnIKQUz8gtrIdDSFQlxUhsoGKOCLOvCgMUxDkRNhjhn6/qwO0brV12iCFuCWYCoLb0hoZhrqeOPyo63mERzfekhHOQdC2QG6ztJ5ihk64rIvey5E86YyI8W6QRTNXdmXvLzrnb0FoZxHIs/OcFn95/T29C9/o4+vif3P7/A/o8zreUB0ZW+4Yvp9J2UpLJnovYg32tqidiYmeFsFYdYKQc9d7yeE4FnSxSo3rV0BSmbiwWVLUce3hFKJ4wynp3r3nnqT8oTwdk9rvT42abOYLGoyPNNy6/QglDlUBO24gRzadgHLKd2rO8Gc4HTndPkFJMvnRazBRZ8o+5UT5PGpf21r5vrCnwjm1e4G8pI+1tUKC6RyANN5QmE4E5CsE5oeKKE/K4JuTsJuXVC4EQJDbsm1G8iVAVk9s6JEnJA14j8R9Oc3p+dLCPYNaOBxWj84bJhJTrVWsHpvFhw7HruOBYd1TnTJgLTzh8GRs/Dqv9oXQdbJWXXdceR2Fon1VDftUvKru/gC6kmUg11Xruk7DrvOJai1kk11XvtovIsVN4LqkZUna9Udmnef0HViKqhQm8VFbSXqtlNpUAHr1Pw5ijYPQOc7eK88/dE0F6eTpVF52+EoL3+DI4CRvtJreuqDtrrj/+CqhFV149KfRuVRQrH4YX6LidbAUVJQoI6nDrJvRMcrPhDNlKdh1MivlaOvykN555uTVOtMGtsTCOMsCHEuJiziMWIXpbSbVcBYIgAaHIVALxB1iPR8U1hiGrklgw80y5tyVrGmFyl+cgICw9RRj7VPyoO4DU4gJFxTJEgD3X1TV6hr/CJEXnhwv2KLxpFqTo6H1W3QV1jIvkFWCspXe1xveZpwSgSiEdYWIqkX6FNZdhSDUj22O9uXccD++3aHq/tKkMmt6AMoALJX8SU/da1B30qdHDUgsv/uWKm4yzJUs2FHOCAZVp2yqNI7zMtt0aQgleZK2q5tPZ2e6yU5Rc14q3glqlM1MMZURLFKtaly8rQdccq4ZEA0QvdsSBhmIUax9JidFukS01P6vXGPW+qdK0Ey+8qU12PwZjF2wFrRI8l6VoY+34Wxs+QnS13aXg8aIrOw6Xn4X+enpHMHLB5Jb8CYG96Plx2ltOb5b09YHSI52ltXynkdprunR3lxpPz+7Yi+I/m90Ft/IHy+6i9/K6UnHqGV/n9YBneO1iGl83yp2K575W/t3MvfwM=</diagram></mxfile>"}'></div><script type=text/javascript src=https://viewer.diagrams.net/js/viewer-static.min.js></script></div></div><h3 id=esempi-2>Esempi</h3><ul><li><p>Saltare all&rsquo;etichetta <code>.fine</code> se il valore del registro <code>x11</code> è nullo</p><pre><code>  BEQ x11, x0, .fine
</code></pre></li><li><p>Saltare all&rsquo;etichetta <code>.inizio</code> se il valore del registro <code>x11</code> è non nullo</p><pre><code>  BNE x11, x0, .inizio
</code></pre></li><li><p>Saltare all&rsquo;etichetta <code>.fine</code> se il valore del registro <code>x11</code> è negativo</p><pre><code>  BLT x11, x0, .fine
</code></pre></li><li><p>Saltare all&rsquo;etichetta <code>.loop</code> se il valore del registro <code>x11</code> è positivo (si usa l&rsquo;idea
che <code>x11>0</code> è equivalente a <code>0&lt;x11</code> in modo da usare <code>BLT</code>)</p><pre><code>  BLT x0, x11, .loop
</code></pre></li><li><p>Saltare all&rsquo;etichetta <code>.fine</code> se il valore del registro <code>x11</code> è negativo o nullo (anche
qui usiamo il fatto che <code>x11&lt;=0</code> equivale a <code>0>=x11</code>)</p><pre><code>  BGE x0, x11, .fine
</code></pre></li></ul><h2 id=link>Link</h2><ul><li><a href=https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/ target=_blank rel=noopener>Interprete RISC-V</a></li><li><a href=https://riscv-programming.org/ale/ target=_blank rel=noopener>Assembly Learning Environment (ALE)</a></li><li><a href=https://www.kvakil.me/venus/ target=_blank rel=noopener>Altro simulatore RISC-V</a></li><li><a href=https://medium.com/swlh/risc-v-assembly-for-beginners-387c6cd02c49 target=_blank rel=noopener>Guida RISC-V (in inglese)</a></li><li><a href=https://github.com/TheThirdOne/rars/releases/tag/continuous target=_blank rel=noopener>Programma di simulazione RISC-V scritto in java</a></li><li><a href=https://github.com/mortbopet/Ripes target=_blank rel=noopener>Programma di simulazione di un CPU RISC-V</a></li></ul></div></article><nav class="mx-5 my-3"><div class=card><h5 class=card-header>Indice di Assembly</h5><ul class="list-group list-group-flush"><li class=list-group-item><a href=https://profschimd.github.io/materie/sr/3/03-assembly/00-assembly/>Linguaggio assembly</a></li><li class="list-group-item list-group-item-primary"><strong><a href=https://profschimd.github.io/materie/sr/3/03-assembly/01-riscv/>> Assembly RISC-V</a></strong></li><li class=list-group-item><a href=https://profschimd.github.io/materie/sr/3/03-assembly/02-load-store/>Load and Store</a></li><li class=list-group-item><a href=https://profschimd.github.io/materie/sr/3/03-assembly/06-subroutine/>Subroutine e gestione dello stack</a></li><li class=list-group-item><a href=https://profschimd.github.io/materie/sr/3/03-assembly/e01-riscv_ex_copia/>Esercizio RISC-V: Copia di array</a></li></ul><div class=card-footer><a class="btn btn-primary" href=https://profschimd.github.io/materie/sr/3/03-assembly/>Index</a></div></div></nav></main></div><div class="py-3 border-top bg-light mt-auto"><div class=container><div class=row><div class=col-sm><ul class=list-unstyled><li>Michele Schimd &copy; 2023</li><li><a class=pr-1 href=mailto:michele.schimd@itiszuccante.edu.it><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-at" viewBox="0 0 16 16"><path d="M.05 3.555A2 2 0 012 2h12a2 2 0 011.95 1.555L8 8.414.05 3.555zM0 4.697v7.104l5.803-3.558L0 4.697zM6.761 8.83.191 12.857A2 2 0 002 14h12a2 2 0 001.808-1.144l-6.57-4.027L8 9.586l-1.239-.757zm3.436-.586L16 11.801V4.697l-5.803 3.546z"/></svg></a><a class=pr-1 rel=me href=https://github.com/ProfSchimd target=_blank title=ProfSchimd alt=GitHub><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-github" viewBox="0 0 16 16"><path d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.012 8.012.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><a class=pr-1 rel=me href=https://www.linkedin.com/in/michele-schimd-44a85160 target=_blank title=michele-schimd-44a85160 alt=Linkedin><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-linkedin" viewBox="0 0 16 16"><path d="M0 1.146C0 .513.526.0 1.175.0h13.65C15.474.0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487.0 14.854V1.146zm4.943 12.248V6.169H2.542v7.225h2.401zm-1.2-8.212c.837.0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248-.822.0-1.359.54-1.359 1.248.0.694.521 1.248 1.327 1.248h.016zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869.0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274.0-1.845.7-2.165 1.193v.025h-.016a5.54 5.54.0 01.016-.025V6.169h-2.4c.03.678.0 7.225.0 7.225h2.4z"/></svg></a><a class=pr-1 rel=me href=https://stackoverflow.com/users/18081937 target=_blank title=18081937><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-stack-overflow" viewBox="0 0 16 16"><path d="M12.412 14.572V10.29h1.428V16H1v-5.71h1.428v4.282h9.984z"/><path d="M3.857 13.145h7.137v-1.428H3.857v1.428zM10.254.0 9.108.852l4.26 5.727 1.146-.852L10.254.0zm-3.54 3.377 5.484 4.567.913-1.097L7.627 2.28l-.914 1.097zM4.922 6.55l6.47 3.013.603-1.294-6.47-3.013-.603 1.294zm-.925 3.344 6.985 1.469.294-1.398-6.985-1.468-.294 1.397z"/></svg></a></li><li><span style=font-size:small><em>Ultimo aggiornamento: 06/11/2023</em></span></li></ul></div><div class="col-lg text-right"><ul class=list-unstyled><li>Materiale di studio e di esercizio per gli alunni dello Zuccante.</li></ul><div><p><a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/><img style=float:right alt="Creative Commons License" src=https://i.creativecommons.org/l/by-nc/4.0/88x31.png></a></div></p></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js integrity=sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js integrity=sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF crossorigin=anonymous></script></body></html>