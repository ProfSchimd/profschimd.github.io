<!doctype html><html><head><meta charset=utf-8><title>Alberi &ndash; Michele Schimd</title><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://cdn.jsdelivr.net/npm/bootswatch@4.5.2/dist/spacelab/bootstrap.min.css rel=stylesheet><link href=https://profschimd.github.io/css/syntax.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css><script src=https://code.jquery.com/jquery-3.4.1.slim.min.js integrity=sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n crossorigin=anonymous></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class="d-flex flex-column min-vh-100"><header><nav class="p-1 navbar navbar-expand-lg navbar-dark bg-primary"><div class=container><a class=navbar-brand rel=author href=https://profschimd.github.io/>Michele Schimd</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav ml-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-expanded=false>Materie</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a href=https://profschimd.github.io/materie/inf/ class=dropdown-item>Informatica</a></li><li><a href=https://profschimd.github.io/materie/sr/ class=dropdown-item>SR</a></li><li><a href=https://profschimd.github.io/materie/tpsit/ class=dropdown-item>TPSIT</a></li><li><a href=https://profschimd.github.io/materie/gpoi/ class=dropdown-item>GPOI</a></li><li><a href=https://profschimd.github.io/materie/ec/ class=dropdown-item>EC</a></li><li><a href=https://profschimd.github.io/materie/python/ class=dropdown-item>Python</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-expanded=false>Classi</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a href=https://profschimd.github.io/classi/4ia/ class=dropdown-item>4IA</a></li><li><a href=https://profschimd.github.io/classi/4ic/ class=dropdown-item>4IC</a></li><li><a href=https://profschimd.github.io/classi/5ic/ class=dropdown-item>5IC</a></li><li><a href=https://profschimd.github.io/classi/5id/ class=dropdown-item>5ID</a></li><li><a href=https://profschimd.github.io/classi/anni-passati/ class=dropdown-item>Anni precedenti</a></li></ul></li><li class=nav-item><a class=nav-link href=https://profschimd.github.io/about/ role=button><i class="bi bi-info-circle"></i></a></li></ul></div></div></nav></header><div class="p-4 bg-primary" style="background-size:cover;background-position:50%;background-image:linear-gradient(to bottom,rgba(0,0,0,.3) 0%,rgba(0,0,0,.6) 100%),url(https://profschimd.github.io/img/zuccante_it.jpeg)"><div class=container><h1 class="display-4 text-white">Alberi</h1></div></div><div class=bg-light><nav aria-label="breadcrumb mt-0"><div class=container><ol class=breadcrumb><li class=breadcrumb-item><a href=https://profschimd.github.io/>Home</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/>Materie</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/inf/>Informatica</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/inf/4/>Quarto anno</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/inf/4/04-grafi-alberi/>Grafi e Alberi</a></li><li class="breadcrumb-item active" aria-current=page><a href=https://profschimd.github.io/materie/inf/4/04-grafi-alberi/01-alberi/>Alberi</a></li></ol></nav></div><div class="container py-5"><main><div class=row><div class=col-10><aside><nav id=TableOfContents><ul><li><a href=#concetti-sugli-alberi>Concetti sugli alberi</a><ul><li><a href=#adt-albero>ADT Albero</a></li><li><a href=#alberi-in-java>Alberi in Java</a></li><li><a href=#semplici-algoritmi-su-alberi>Semplici algoritmi su alberi</a></li></ul></li><li><a href=#alberi-binari>Alberi binari</a></li><li><a href=#visite-di-un-albero>Visite di un albero</a><ul><li><a href=#pre-order>Pre-order</a></li><li><a href=#in-order>In-order</a></li><li><a href=#post-order>Post-order</a></li><li><a href=#breadth-first>Breadth-first</a></li></ul></li><li><a href=#alberi-di-ricerca-binari>Alberi di ricerca binari</a><ul><li><a href=#ricerca-binaria>Ricerca binaria</a></li></ul></li><li><a href=#riferimenti>Riferimenti</a></li></ul></nav></aside></div><div class=col-2><a class="btn btn-outline-primary my-1 w-100" href=https://github.com/ProfSchimd/teaching-material/tree/main/inf/datastructure/tree role=button target=_blank><i class="bi bi-github"></i> Source</a></div></div><article><div class=container style=text-align:justify><p>Le strutture dati ad albero sono usate per rappresentare le informazioni che abbiano
una <em>struttura gerarchica</em>, il tipico esempio di una struttura gerarchica è dato dai
rapporti di parentela, un altro esempio è dato dall&rsquo;organizzazione dei file e delle
cartelle all&rsquo;interno del <em>filesystem</em> di un computer.</p><p>In tutti questi casi, ed in molti altri, la struttura migliore per mantenere i dati
organizzati è quella ad albero. Tuttavia gli alberi sono molto utilizzati anche come
struttura per favorire la <em>ricerca</em>.</p><h2 id=concetti-sugli-alberi>Concetti sugli alberi</h2><div class=row><div class=col-7><p>Facendo riferimento alla figura a sinistra, vediamo subito che, normalmente, il modo
di disegnare un albero è contrario rispetto a quello che si si aspetterebbe, l&rsquo;albero
infatti cresce e si ramifica verso il basso, anziché verso l&rsquo;altro, come gli alberi
biologici.</p><p>Sempre dall&rsquo;immagine a sinistra si vede che una struttura ad albero, a meno che non
sia vuoto, ha sempre una <strong>radice</strong> (<em>root</em>), nell&rsquo;esempio <code>Alice</code> che è l&rsquo;inizio
dell&rsquo;albero. Le frecce indicano la direzione in cui l&rsquo;albero cresce, ad un certo
punto la crescita si ferma in corrispondenza delle <strong>foglie</strong> (<em>leaves</em>) indicate
in verde nella figura. Esempi di foglie, quindi, sono <code>Gill</code>, <code>Henry</code>, <code>Nick</code>, &mldr;</p><p>Ogni elemento dell&rsquo;albero viene chiamato <strong>nodo</strong> (<em>node</em>) ed è collegato da <strong>archi</strong>
(<em>arcs</em>) con i propri <strong>figli</strong> (<em>children</em>) e con l&rsquo;unico <strong>padre</strong> (<em>parent</em>).
Ad esempio <code>Fred</code> ha come figli <code>Jean</code> e <code>Kevin</code> e come padre <code>David</code>.
Si noti che <em>i nodi foglia non hanno figli</em> mentre i nodi con figli vengono chiamati
<strong>nodi interni</strong>, anche la radice che non ha padre è sempre un nodo interno, se la
radice non ha figli è sia nodo interno sia foglia (ed è l&rsquo;unico caso possibile).</p><p>L&rsquo;utilizzo dell&rsquo;analogia con i gradi di parentela viene spesso usato per indicare
anche relazioni non dirette, nodi con lo stesso padre sono chiamati <strong>fratelli</strong>
(<em>siblings</em>), i figli, i figli dei figli, e via dicendo sono i <strong>discendenti</strong>
(<em>descendants</em>) di un nodo. Ad esempio, <code>Bob</code> ha come discendenti <code>Carol</code>, <code>Henry</code>
e <code>Ian</code>. Allo stesso modo il padre, il padre del padre e così via, rappresentano
gli <strong>antenati</strong> (<em>ancestors</em>) di un nodo. Ad esempio <code>Laura</code> ha come antenati
<code>Jean</code>, <code>Fred</code>, <code>David</code> e <code>Alice</code>.</p></div><div class=col-5><div class=mxgraph style="max-width:100%;border:1px solid transparent" data-mxgraph='{"highlight":"#0000ff","nav":true,"resize":true,"toolbar":"zoom layers tags lightbox","edit":"_blank","xml":"<mxfile host=\"app.diagrams.net\" modified=\"2022-11-30T16:54:17.241Z\" agent=\"5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36\" version=\"20.6.0\" etag=\"nPKeBJWY1n6K557sKf7v\" type=\"google\"><diagram id=\"tzfsWCWBua0S9OpXUU1r\" name=\"Page-1\">7ZtdU+IwFIZ/DZfrtGmblksXQddVx1l3ZnXvYhshmjZMCF/76zelKW0JslWBwFacEXKatD158p6cNNByOvHsnKPh4JpFmLaAFc1azlkLANvxAvmWWuaZxbfamaHPSaQqFYY78gcro6WsYxLhUaWiYIwKMqwaQ5YkOBQVG+KcTavVnhitXnWI+lgz3IWI6tZfJBIDZbVhuzhwgUl/oC4dAD87EKO8svJkNEARm5ZMTrfldDhjIvsUzzqYpp2X90vWrvfK0eWNcZyIOg0guY2mYfQ8fHE7v2nQi2F0+UV5MRLz3GEcSf9VkXExYH2WINotrF85GycRTs9qyVJR54qxoTTa0viMhZgrmGgsmDQNREzV0SeWiB6KCU3HxE8SS77AusFT+f8Hi1Giqqj2NpTl7DbTe3vVe2UasTEP8QaX81GEeB+LDfXcJSM5uDGLseBz2Y5jigSZVO8DqVHWX9YrQMgPisUbuNi2BubD3Y5nRNynzU88VXooHTmbqTMvCvO8kEhv7suFh3KhaLQo5a2OA7BnFHB23gmiY3WlU0qkW69TT0FNB0TguyFa+D+VEffDwnoilHYYZXxxOecpCHEYSvtIcPaCS0ceA8/1crglO4SWfC0JTjAXeLaZod7nqoHneVkTNVlAFTqnReTNTYNSzHWtXUFyN4bHhCVbiYfvEaZZiYGaEnNMSgxoEvvKHo0LzEv/dBllr3XCg4vXdgTm5mmVEpjtmlaYf7AKK6a+E987ntnPqSlN2+z0F+yHe8EQ7Jrhe8aYCe7QJHdHi8kdxBn9jMrlqAwc01EZHENUPqKg7NYUp1Ft2s6+Y/J/HpLrUvdNUne1iHyGJrJFoyPy6kLUeJ7saZTOCTU+bUYeDiJ3HYwAPDoLGCv4LCt9XrAdSL51YIsZqEHqLnq30ZQ8cGDJzTJ8H3Ryc0xLTr/u0qNtcqIDe0pqm7PkrMu9tN1lgLuvReUexw3Pb6B1YEE50CDpYk2i03RDV5ZCikYjElaZVJW7JzUt1W6/Repb1GDdzS6wfjyUeHtreOe22kpVV7hlRDpS5AD+ynBbHUeZm6pVMZS0E8GVZMJur5wo6wftRIsxuXT7A0tkPQ+/wAlveIrnrOB1gOnnV3om/k12Y6Mhud6BQQJw3/nYznNqw/mY3a47GZjdl93Pnp/hL6HUZmH0e0bgcx/OmAjNbsC2tSnyEpufIw0/9oWHNkdaGqXveEKMYzKbykD30DDp29pXaMxRszG57Som13ZOvHqgYF5x+6j0/a5rRKX/DV/DrYY+N//u4z9R7QqUvtS+IeFLsynBPF/bPSVZLH6bkD0/KX7h4XT/Ag==</diagram></mxfile>"}'></div><script type=text/javascript src=https://viewer.diagrams.net/js/viewer-static.min.js></script></div></div><p>Riassumiamo quindi le varie cose viste in alcune definizioni</p><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-journal-text"></i> Definizione: Albero</strong></h5><p>Un <strong>albero</strong> (<em>tree</em>) è una struttura dati gerarchica costituita da <strong>nodi</strong> (<em>nodes</em>)
collegati mediante <strong>archi</strong> (<em>arcs</em>). Ogni albero non vuoto ha un nodo <strong>radice</strong>
(<em>root</em>), ogni nodo può avere dei <strong>figli</strong> (<em>children</em>), nodi senza figli si dicono
<strong>foglie</strong> (<em>leaves</em>) mentre gli altri nodi sono detti <strong>nodi interni</strong> (<em>internal nodes</em>).
Tutti i nodi ad eccezioni della radice hanno <em>esattamente un nodo padre</em> e nessun nodo
può essere antenato di un suo antenato, in altre parole negli alberi non ci devono
essere <em>cicli</em> (percorsi chiusi, cioè che ritornano sullo steso nodo)</p></div><div class="alert alert-danger" markdown=1><h5 class="alert-danger no_toc"><i class="bi bi-exclamation-triangle"></i> Attenzione</strong></h5><p>In certi casi gli archi negli alberi non vengono rappresentati come frecce, ma
semplicemente come dei segmenti (<em>lati</em>) che collegano i vari nodi. Questo succede
soprattutto quando si interpretano gli alberi come casi particolari di grafi.
Un caso noto è l&rsquo;algoritmo per trovare, in un grafo, l&rsquo;<em>albero di copertura minimale</em>
(<em>minimum spanning tree</em>), in questo caso il grafo potrebbe essere <em>non orientato</em>
(senza frecce) che determinerebbe un albero di copertura, a sua volta, senza frecce.</p></div><p>Completiamo quindi la lista dei &ldquo;gradi di parentela&rdquo; in un albero:</p><ul><li><em>padre</em> (<em>parent</em>): unico nodo antenato diretto (la radice non ha padre)</li><li><em>figli</em> (<em>children</em>): nodi discendenti diretti (collegate da una freccia)</li><li><em>discendenti</em> (<em>descendants</em>): figli, nipoti, pro-nipoti, &mldr;,</li><li><em>antenati</em> (<em>ancestor</em>): padre, nonno, bisnonno, &mldr;</li><li><em>fratelli</em> (<em>siblings</em>): nodi che hanno lo stesso padre</li><li><em>cugini</em> (<em>cousins</em>): nodi con padre diverso, ma alla stessa <em>altezza</em> (vedi sotto)</li></ul><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-journal-code"></i> Esempio</strong></h5><p><p>Vediamo alcuni esempi di &ldquo;parentela&rdquo; riferendoci all&rsquo;albero della figura sopra.</p><ul><li><code>Alice</code> è il padre di <code>Bob</code>, <code>David</code> e <code>Gill</code>; <code>Bob</code> è il padre di <code>Carol</code>; &mldr;</li><li><code>Emily</code> e <code>Fred</code> sono figli di <code>David</code>; <code>Henry</code> e <code>Ian</code> sono figli di <code>Carol</code>; &mldr;</li><li><code>Carol</code>, <code>Henry</code> e <code>Ian</code> sono discendenti di <code>Bob</code>, <code>Gill</code> non ha discendenti; &mldr;</li><li><code>Fred</code> è antenato di <code>Jean</code>, <code>Kevin</code>, <code>Laura</code>, <code>Mallory</code> e <code>Nick</code>, <code>Alice</code> è antenato di tutti; &mldr;</li><li><code>Bob</code>, <code>David</code> e <code>Gill</code> sono fratelli; <code>Carol</code> non ha fratelli; &mldr;</li><li><code>Carol</code> è cugino di <code>Emily</code> e <code>Fred</code>; <code>Henry</code> è cugino di <code>Jean</code> e <code>Fred</code>; &mldr;</li></ul></p></div><p>La sequenza di nodi che si ottiene percorrendo un albero viene chiamato <strong>percorso</strong>
(<em>path</em>). Partendo dalla radice è possibile raggiungere i vari nodi attraverso
uno specifico percorso. Da un nodo qualsiasi è inoltre possibile raggiungere la
radice e uno qualsiasi degli antenati attraverso un unico percorso.</p><p>Dato un nodo, chiamiamo <strong>profondità</strong> (<em>depth</em>) di quel nodo il numero di antenati,
ad esempio <code>Fred</code> ha profondità 2 (i suoi due antenati sono <code>David</code> e <code>Alice</code>),
<code>Mallory</code> ha profondità 4; la radice (<code>Alice</code> nell&rsquo;esempio) ha profondità 0.</p><p>Inoltre ad ogni nodo associamo un&rsquo;<strong>altezza</strong> (<em>height</em>) che è il numero massimo
di discendenti sullo stesso percorso, ad esempio l&rsquo;altezza di <code>Bob</code> è 2,
l&rsquo;altezza di <code>David</code> è 3, l&rsquo;altezza di <code>Gill</code> è 0. Chiamiamo <strong>altezza dell&rsquo;albero</strong>
l&rsquo;altezza della radice, nell&rsquo;esempio l&rsquo;altezza di <code>Alice</code> è 4, quindi l&rsquo;albero
nella figura ha altezza 4.</p><p>Riassumiamo i concetti esposti nella seguente definizione.</p><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-journal-text"></i> Definizione: Profondità e altezza</strong></h5><p>La <strong>profondità</strong> (<em>depth</em>) di un nodo è il numero di <em>antenati</em> di quel nodo,
l&rsquo;<strong>altezza di un nodo</strong> (<em>node height</em>) il numero massimo di discendenti,
l&rsquo;<strong>altezza di un albero</strong> (<em>tree height</em>) è l&rsquo;altezza del nodo radice.</p></div><h3 id=adt-albero>ADT Albero</h3><p>Una struttura dati astratta per gli alberi dovrebbe comprendere alcune
operazioni per l&rsquo;accesso ai nodi dell&rsquo;albero. Le modifiche ad un albero
solitamente si fanno accedendo direttamente ai nodi coinvolti</p><ul><li><code>Root</code> restituisce la radice dell&rsquo;albero.</li><li><code>Size</code> restituisce il numero totale di nodi dell&rsquo;albero.</li><li><code>AllNodes</code> restituisce tutti i nodi dell&rsquo;albero.</li><li><code>InternalNodes</code> restituisce i nodi <em>interni</em> dell&rsquo;albero.</li><li><code>Leaves</code> restituisce i nodi <em>foglia</em> dell&rsquo;albero.</li><li><code>Search</code> restituisce, se esiste, il nodo con valore dato.</li><li><code>SetRoot</code> imposta il nodo radice dell&rsquo;albero.</li></ul><h3 id=alberi-in-java>Alberi in Java</h3><p>Come nel caso delle liste, anche le strutture dati ad albero utilizzando il concetto
di posizione che chiamiamo <em>nodo</em>. I nodi sono collegati tra di loro in modo da
formare la struttura di albero. Negli alberi i collegamenti esistono tra un nodo
e i suoi figli, nella pratica viene anche utilizzato un collegamento da un nodo
verso il proprio padre. Ovviamente le foglie non hanno collegamento verso i figli
mentre la radice non ha collegamento al padre.</p><p>Il nodo contiene anche un <em>valore</em> che rappresenta l&rsquo;informazione che si vuole
memorizzare. Nell&rsquo;esempio sopra il nodo radice (colorato di rosso) conterrà il
valore <code>Alice</code> ed avrà il collegamento ai figli che sono tre nodi contenenti i
valori <code>Bob</code>, <code>David</code> e <code>Gill</code>.</p><p>L&rsquo;interfaccia Java per un nodo dell&rsquo;albero viene mostrata di seguito.</p><h4 id=la-classe-treenode>La classe <code>TreeNode</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>ITreeNode</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Object</span> <span class=nf>value</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ITreeNode</span> <span class=nf>parent</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ITreeNode</span><span class=o>[]</span> <span class=nf>children</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setValue</span><span class=o>(</span><span class=n>Object</span> <span class=n>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setParent</span><span class=o>(</span><span class=n>ITreeNode</span> <span class=n>parent</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>addChild</span><span class=o>(</span><span class=n>ITreeNode</span> <span class=n>child</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>removeChild</span><span class=o>(</span><span class=n>ITreeNode</span> <span class=n>child</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>isRoot</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>isLeaf</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>isInternal</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>L&rsquo;interfacci contiene diversi metodi per:</p><ul><li>interrogare il nodo<ul><li><code>value()</code> restituisce il valore</li><li><code>parent()</code> restituisce il padre</li><li><code>children()</code> restituisce tutti i figli</li></ul></li><li>modificare il nodo<ul><li><code>setParent()</code> imposta il collegamento al padre</li><li><code>addChild()</code> aggiunge il collegamento ad un nuovo figlio</li><li><code>removeChild()</code> rimuove il collegamento ad un figlio esistente</li></ul></li><li>utili informazioni<ul><li><code>isRoot()</code> determina se il nodo è radice</li><li><code>isLeaf()</code> determina se il nodo è una foglia</li><li><code>isInternal()</code> determina se il nodo è interno</li></ul></li></ul><p>L&rsquo;implementazione in Java dell&rsquo;interfaccia <code>ITreeNode</code> viene lasciata come
esercizio in quanto non richiede particolari accorgimenti (ad eccezione do
<code>addChild</code> e <code>removeChild</code> che devono mantenere la struttura ad albero).</p><h4 id=la-classe-tree>La classe <code>Tree</code></h4><p>In pratica la struttura ad albero è interamente determinata dai collegamenti
tra i nodi. Per questo motivo l&rsquo;interfaccia <code>ITree</code> sotto dichiarata non contiene
metodi per la modifica, ma solo per la sua interrogazione. L&rsquo;unica eccezione
è rappresentata dal metodo <code>setRoot</code> che permette di impostare il nodo radice</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>ITree</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ITreeNode</span> <span class=nf>getRoot</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setRoot</span><span class=o>(</span><span class=n>ITreeNode</span> <span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ITreeNode</span><span class=o>[]</span> <span class=nf>getNodes</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ITreeNode</span><span class=o>[]</span> <span class=nf>getLeaves</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ITreeNode</span><span class=o>[]</span> <span class=nf>getInternalNodes</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>size</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>isEmpty</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ITreeNode</span> <span class=nf>search</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>   
</span></span></code></pre></div><p>Notiamo anche l&rsquo;esistenza di un metodo <code>search</code> che permette di cercare un
dato oggetto all&rsquo;interno dell&rsquo;albero. La ricerca in un albero è un problema
che merita di essere trattato a parte, in particolare quando si parlerà di
<a href=#visite-di-un-albero>visite di un albero</a>.</p><div class="alert alert-success" markdown=1><h5 class=no_toc><i class="bi bi-eye"></i> Osserva</strong></h5><p><p>Le interfacce <code>ITreeNode</code> e <code>ITree</code> sopra sono state definite in modo che
per indicare un albero sia sufficiente dire chi è il nodo radice. Una volta
ottenuto un collegamento alla radice è possibile navigare l&rsquo;albero in modo
da raggiungere tutti i suoi nodi.</p><p>In realtà un qualsiasi nodo dell&rsquo;albero sarebbe sufficiente per poter
raggiungere tutti i nodi. Infatti è sempre possibile seguire i collegamenti
al padre fino a raggiungere la radice dalla quale si può poi raggiungere
ogni altro nodo.</p></p></div><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-pencil-square"></i> Esercizio</strong></h5><p><p>Implementare in Java l&rsquo;interfaccia <code>ITreeNode</code> descritta sopra mediante una
classe concreta di nome <code>TreeNode</code>. Oltre ai metodi dell&rsquo;interfaccia la classe
deve prevedere un costruttore che imposti il <em>valore</em> (<code>value</code>) del node, il riferimento
al <em>nodo padre</em> (<code>parent</code>) e la <em>lista dei figli</em> (<code>children</code>). La firma del
costruttore sarà quindi:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>TreeNode</span><span class=o>(</span><span class=n>Object</span> <span class=n>value</span><span class=o>,</span> <span class=n>ITreeNode</span> <span class=n>parent</span><span class=o>,</span> <span class=n>ITreeNode</span><span class=o>[]</span> <span class=n>children</span><span class=o>)</span>
</span></span></code></pre></div></p></div><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-pencil-square"></i> Esercizio</strong></h5><p>Implementare in Java l&rsquo;interfaccia <code>ITree</code> descritta sopra mediante una
classe concreta di nome <code>Tree</code>. Oltre ai metodi dell&rsquo;interfaccia, la
classe deve prevedere un costruttore senza parametri che crea un albero
vuoto.</p></div><div class="alert alert-danger" markdown=1><h5 class="alert-danger no_toc"><i class="bi bi-exclamation-triangle"></i> Attenzione</strong></h5><p><p>Il metodo <code>size()</code> della classe deve restituire il numero di nodi complessivamente
memorizzati nell&rsquo;albero. Questa operazione potrebbe essere realizzata tenendo
traccia dei nodi presenti con una variabile <code>n</code>, tuttavia risulta difficile
aggiornare tale variabile in quanto operazioni su alcuni nodi potrebbero cambiare
il numero <code>n</code> senza che la classe <code>Tree</code> sia in grado di aggiornarlo. Ad esempio
il codice</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Tree</span> <span class=n>tree</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Tree</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=c1>// aggiunge radice ed altri nodi a &#39;tree&#39;
</span></span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>tree</span><span class=o>.</span><span class=na>getRoot</span><span class=o>().</span><span class=na>addChild</span><span class=o>(</span><span class=k>new</span> <span class=n>TreeNode</span><span class=o>());</span>
</span></span></code></pre></div><p>aggiunge un figlio alla radice usando il metodo <code>addChild</code> che, appartiene ad
<code>ITreeNode</code> e non ad <code>ITree</code>, come si fa, quindi, ad aggiornare <code>n</code>?</p></p></div><div class="alert alert-danger" markdown=1><h5 class="alert-danger no_toc"><i class="bi bi-exclamation-triangle"></i> Attenzione</strong></h5><p>La <em>ricerca</em> (<code>search</code>) all&rsquo;interno di un albero verrà
discussa sotto nella sezione <a href=#visite-di-un-albero>visite di un albero</a>.
Lo studente può comunque provare a realizzare una propria idea di ricerca
come utile esercizio di pratica.</p></div><h3 id=semplici-algoritmi-su-alberi>Semplici algoritmi su alberi</h3><p>Vediamo qui alcuni semplici algoritmi su alberi.</p><h4 id=profondità-di-un-nodo>Profondità di un nodo</h4><p>Abbiamo visto sopra che la <em>profondità</em> di un nodo è il numero di antenati di quel
nodo, dato un <code>ITreeNode</code> come possiamo calcolare la sua profondità? La strategia
risolutiva è molto semplice e sfrutta la ricorsione.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>getDepth</span><span class=o>(</span><span class=n>ITreeNode</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>parent</span><span class=o>()</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>getDepth</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>parent</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></td></tr></table></div></div><p>L&rsquo;algoritmo è semplice:</p><ul><li>se il nodo è la radice (<code>node.parent() == null</code>), allora la sua profondità è <code>0</code>,</li><li>altrimenti la sua profondità sarà uno più della profondità del padre per calcolare
la quale usiamo la ricorsione (<code>getDepth(node.parent())</code>).</li></ul><h4 id=altezza-di-un-nodo>Altezza di un nodo</h4><p>Il calcolo dell&rsquo;altezza di un nodo utilizza un approccio simile al calcolo della
profondità, tuttavia ci sono due importanti differenze:</p><ul><li>la ricorsione sarà sui figli anziché sul padre e quindi <em>ci saranno tante chiamate
ricorsive quanti sono i figli</em>;</li><li>una volta che conosco l&rsquo;altezza dei figli devo prendere il massimo di queste per
calcolare l&rsquo;altezza del nodo.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>getHeight</span><span class=o>(</span><span class=n>ITreeNode</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &#39;node&#39; is a leaf, its height is 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>isLeaf</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// get the height of each children
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ITreeNode</span><span class=o>[]</span> <span class=n>children</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>children</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>[]</span> <span class=n>childrenHeights</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>children</span><span class=o>.</span><span class=na>length</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>children</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>childrenHeights</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>getHeight</span><span class=o>(</span><span class=n>children</span><span class=o>[</span><span class=n>i</span><span class=o>]);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// get the height of the highest child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>maxHeight</span> <span class=o>=</span> <span class=n>childrenHeights</span><span class=o>[</span><span class=mi>0</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>childrenHeights</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>maxHeight</span> <span class=o>=</span> <span class=o>(</span><span class=n>maxHeight</span> <span class=o>&gt;</span> <span class=n>childrenHeights</span><span class=o>[</span><span class=n>i</span><span class=o>])</span> <span class=o>?</span> <span class=n>maxHeight</span> <span class=o>:</span> <span class=n>childrenHeights</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>maxHeight</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=alberi-binari>Alberi binari</h2><p>Finora abbiamo visto che non c&rsquo;è limite al numero di figli che un nodo di un albero
può avere. Se prendiamo l&rsquo;intero albero chiamiamo <strong>arietà</strong> (<em>arity</em>) il numero di
figli del suo nodo con il maggior numero di figli. Nell&rsquo;esempio sopra l&rsquo;albero ha
arietà 3 in quanto sia <code>Alice</code> che <code>Jean</code> hanno tre figli mentre gli altri nodi
interni ne hanno meno di 3.</p><p>Per avere una struttura ad albero e non una semplice lista (che è un albero con
arietà 1), l&rsquo;albero deve avere almeno arietà 2. Cioè deve esistere almeno un nodo
con almeno due figli. Chiamiamo <strong>albero binario</strong> (<em>binary tree</em>) un albero in
cui tutti i nodi hanno <em>al massimo due figli</em> (tuttavia, possono averne uno o zero).</p><p>In un albero binario possiamo semplificare la gestione dei figli di un nodo in
quanto questi possono essere 0, 1 o 2. Spesso si fa riferimento ai figli <em>sinistro</em>
(<em>left child</em>) e <em>destro</em> (<em>right child</em>) immaginando l&rsquo;albero disegnato nel modo
che abbiamo visto sopra.</p><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-journal-code"></i> Esempio</strong></h5><p>Come già detto, l&rsquo;albero dell&rsquo;esempio sopra non è binario poiché ci sono due
nodi con tre figli. Se però consideriamo il sottoalbero la cui radice è <code>Bob</code>,
allora vediamo che si tratta di un albero binario con <code>Bob</code> che come unico
figlio <code>Carol</code> (che può essere sia destro che sinistro) il quale ha due figli
<code>Henry</code> (figlio sinistro) e <code>Ian</code> (figlio destro).</p></div><div class=row><div class=col-6><p>Vediamo un esempio di albero binario dove il contenuto di ogni nodo è un intero
anziché una stringa (utilizzando le interfacce Java definite sopra si dovrà usare
la classe <code>Integer</code>, perché?).</p><p>A destra troviamo un esempio in cui ci sono nodo con 0, 1 e 2 figli mentre non ci
sono nodi con 3 o più figli, ne segue che l&rsquo;albero a destra è un albero binario.</p><p>La radice dell&rsquo;albero contiene il valore <code>53</code> ed ha due figli, il figlio sinistro
che contiene il valore <code>42</code> ed il figlio destro che contiene il valore <code>56</code>.
Vediamo inoltre come il nodo con valore <code>21</code> ha un solo figlio, dal disegno possiamo
dedurre che si tratti del nodo destro. L&rsquo;albero, inoltre, contiene complessivamente
9 foglie.</p><p>Abbiamo già detto che un nodo qualsiasi si può considerare come radice di un sottoalbero,
negli alberi binari per ogni nodo possiamo avere due sottoalberi uno con radice il figlio
sinistro ed uno con radice il figlio destro.</p></div><div class=col-6><div class=mxgraph style="max-width:100%;border:1px solid transparent" data-mxgraph='{"highlight":"#0000ff","nav":true,"resize":true,"toolbar":"zoom layers tags lightbox","edit":"_blank","xml":"<mxfile host=\"app.diagrams.net\" modified=\"2022-12-05T16:41:56.352Z\" agent=\"5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36\" version=\"20.6.0\" etag=\"ynK0ultwgZkSbxLFRfPH\" type=\"google\"><diagram id=\"96RvyZuFx0hoK3hczf1f\" name=\"Page-1\">7Vxdc6MgFP01eeyOgJ+vm7a7D7t92O5M20cmkuhWJWNIY/bXL0aMuJjUznQCGUlnGrmCgvccDlwwMzTPq28lXic/aUyyGXTiaoZuZxAC5AH+VVv2jSUIg8awKtNYZOoMj+lfIoyOsG7TmGx6GRmlGUvXfeOCFgVZsJ4NlyXd9bMtada/6xqviGJ4XOBMtT6lMUuEFfhRd+I7SVeJuHUIRfty3GYWLdkkOKY7yYTuZmheUsqao7yak6x+eO1zacrdnzh7rFhJCjamwPYpu3moXvcbuk1W+AelT0V+Iyq7Yfu2wSTm7RfJghb862tJt0VM6ss4PEVLltAVLXDGr7HmRsCNfwhje+E9vGWUmxKWZ+IsqVL2LB2/SMe3lbjuIbFvEwUr989y4kVOdIUOqbbUkhbsHudpVht+pzkHDnQeyI7//0VzXIgsop4I1uk0y+Y0o+Wh9Wjp1X/cvmElfSXSGf/wEVeQ7M2H25snWT++kw4SJu6BckHOeAUKoONyRdiZfO4RRpx/hOaEPwxeriQZZulbvx5YEGF1zNdhhR8IuHwAOtFFoeN8HDrAQud0vlAndEQl33C2FXfykIqmLOOdfA2iXZIy8rjGh4bvuM70IYI366bnX6ZVDTXVUSN8e8KXpzx22seiaaRkpDrvTfXpiwKe5zVFhGa6QkF2nQD5wpRI0tPaPt1d4LIqYak+juruSKoDTyfXQWiHGNcMHl8neFxVKHwrFEehCD2nJxQg1K0UAzJuya6d7OFYskOtSuHaYcY1g+dEX3UZ8ISKUrjQKsVRKaBpSnGEn7Fkd754U6Q7aKOs7/I90sl3OMBuw0YaFj9n8SMFwXUMNoAiGMdAvRWMeuWmLxgI6J5aqEFDdyC0MFmHocAwh0Hjo4ZT7aG9sT000qrw5gcOLX7O40fr+mRbTTl46FnBOApGYJrCQ+NXlKdKeH8s4bWuNKGB8bsVjKvCj9bFpraakmAEdkrYCUZk2gwDXXa1yQrGaMJHIwmPtK4ZoMsuOFnB+Hz86F2wjBTBsBEpaYLRlwtX9zY2NLB1xNLdALq3gff36a51ftFWU14yGFjFnCzfQWQY4SFSHOYNSP5kHeab1kPDgf1+NmQnKappDHMvu4vDSupoSR0bo0daXwQZ2qNlZ/BXhZ9A65BMXePxbchOCtkB0wTDxugNJfzYGD3Su+1PjdGHAxoyWcIDBxnGeKRutLPvenYO+89dnqfbXVBxF7CvXEkEA6Y5TB0CQdsjdg4zj2GB4jBvYOfLZB0WBqY5TH23yLdRKWmS4ZnmMHVdLrIMkweJl6MYT3Y/cXQ4J/1QFLr7Bw==</diagram></mxfile>"}'></div><script type=text/javascript src=https://viewer.diagrams.net/js/viewer-static.min.js></script></div></div><p>In un albero binario un <em>cammino</em> (<em>path</em>) può essere indicato semplicemente indicando,
per ogni nodo, se si segue il figlio destro o il figlio sinistro. Ad esempio, il cammino
dalla radice (<code>53</code>) alla foglia <code>55</code> può essere descritto indicando il nodo di partenza
(in questo caso la radice) e successivamente indicando i figli attraversati in questo
case: destro (<code>56</code>), sinistro (<code>55</code>) e destro (<code>55</code>).</p><p>La seguente interfaccia estende <code>ITreeNode</code> e definisce l&rsquo;interfaccia <code>BinaryTreeNode</code>
che aggiunge i metodi per recuperare ed impostare i figli sinistro e destro.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>IBinaryTreeNode</span> <span class=kd>extends</span> <span class=n>ITreeNode</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ITreeNode</span> <span class=nf>getLeftChild</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setLeftChild</span><span class=o>(</span><span class=n>ITreeNode</span> <span class=n>child</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ITreeNode</span> <span class=nf>getRightChild</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setRightNode</span><span class=o>(</span><span class=n>ITreeNode</span> <span class=n>child</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-pencil-square"></i> Esercizio</strong></h5><p><p>Partendo dall&rsquo;implementazione di <code>ITreeNode</code>, realizzare un&rsquo;implementazione
dell&rsquo;interfaccia <code>IBinaryTreeNode</code>. Fare attenzione alla gestione dei metodi
<code>addChild</code> e <code>removeChild</code> ereditati da <code>TreeNode</code>. Questa implementazione
deve preveder un costruttore con quattro parametri:</p><ol><li>il valore (<code>value</code>)</li><li>il nodo padre (<code>parent</code>)</li><li>il figlio sinistro (<code>left</code>) e</li><li>il figlio destro (<code>right</code>).</li></ol></p></div><h2 id=visite-di-un-albero>Visite di un albero</h2><p>La <strong>visita</strong> (<em>visit</em>) di un albero è l&rsquo;operazione che attraverso (visita)
tutti i nodi esattamente una volta. Normalmente durante la visita ad un nodo
viene effettuata un&rsquo;operazione, ad esempio la stampa a video del suo valore.
Tuttavia rimane il problema dell&rsquo;<em>ordine in cui visitare</em> i nodi.</p><div class=row><div class=col-8><p>Consideriamo l&rsquo;albero a destra costituito dalla radice e dai suoi due figli.
È possibile visitare tale albero in almeno tre modi diversi.</p><ol><li>Visito prima la radice, poi il figlio sinistro ed infine il figlio destro,
l&rsquo;output ottenuto stampando i valori secondo questa visita è <code>8 3 16</code>, questa
visita si chiama <a href=#pre-order><strong>pre-order visit</strong></a>.</li><li>Visito prima il figlio sinistro, poi la radice poi il figlio destro, l&rsquo;output
in questo caso sarà <code>3 8 16</code>, questa visita si chiama <a href=#in-order><strong>in-order visit</strong></a>.</li><li>Visito prima il figlio sinistro, poi il figlio destro ed infine la radice, l&rsquo;output
in questo caso sarà <code>3 16 8</code>, questa visita si chiama <a href=#post-order><strong>post-order visit</strong></a>.</li></ol><p>Vediamo più in dettaglio come implementare in Java tutte queste visite.</p></div><div class=col-4><div class=mxgraph style="max-width:100%;border:1px solid transparent" data-mxgraph='{"highlight":"#0000ff","nav":true,"resize":true,"toolbar":"zoom layers tags lightbox","edit":"_blank","xml":"<mxfile host=\"app.diagrams.net\" modified=\"2022-12-05T16:56:46.498Z\" agent=\"5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36\" version=\"20.6.0\" etag=\"kuYhMZqupUE8M-2_WszI\" type=\"google\"><diagram id=\"96RvyZuFx0hoK3hczf1f\" name=\"Page-1\">7VZNb5tAEP01HFMZ1oB7rZ20hzaHupKb48qMYZtlBy1LgP767sJgQNRWKkXJocGS2Xkzsx/zHgwe2+bNZ82L7BsmIL1glTQe23lB4LPQtzeHtD0Sb+IeSLVIKGgE9uI3ELgitBIJlLNAgyiNKObgEZWCo5lhXGus52EnlPNVC57CAtgfuVyiB5GYjFA/+jg6voBIM1p6E9D5cj4E00nKjCdYTyB267GtRjT9KG+2IF3xhrr0eXcXvOeNaVDmOQnVQd7cN49tiVWW8q+IB5XfrBltzrTDiSGxBSBTobK3TxorlYCbZ2Ut1CbDFBWXdpLCgr4Ff4ExLdHHK4MWykwuyQuNMD8p3Y0fJviumTh27WAoo9su5UM4mA9T35jWWUPeCZW547mQDvghcqudYHUPtf3/jjlXFEI7ZYGzhZRblKi787NT6H4WL43GR5h4ou6iGSZ4f1m8r6Ur4EWOCLIk6CNcIyYksXOdgrkWGJ21ZB9CwBxsOWyiBsmNeJrvhNPTkJ7jRsHYAWnmX/SzflX9+O/6eXH9xG+qH9rmE5cVLbVZKkpK+7p3QqozYWBf8O7ote04c5nwsuh7wEk0Tm5Lqp7B7gU2L3F2mWU6GWgDzXU+l9WnhJh6BzXP9ZrsemxFEUHZpAkN2MvTFS3o+ksD+W/pYnO6wvCt6YoXdPnRO19nvnz/1Qiz5vip1/kmH8zs9g8=</diagram></mxfile>"}'></div><script type=text/javascript src=https://viewer.diagrams.net/js/viewer-static.min.js></script></div></div><h3 id=pre-order>Pre-order</h3><h3 id=in-order>In-order</h3><h3 id=post-order>Post-order</h3><h3 id=breadth-first>Breadth-first</h3><h2 id=alberi-di-ricerca-binari>Alberi di ricerca binari</h2><h3 id=ricerca-binaria>Ricerca binaria</h3><h2 id=riferimenti>Riferimenti</h2></div></article><nav class="mx-5 my-3"><div class=card><h5 class=card-header>Indice di Grafi e Alberi</h5><ul class="list-group list-group-flush"><li class="list-group-item list-group-item-primary"><strong><a href=https://profschimd.github.io/materie/inf/4/04-grafi-alberi/01-alberi/>> Alberi</a></strong></li><li class=list-group-item><a href=https://profschimd.github.io/materie/inf/4/04-grafi-alberi/02-concetto-di-grafo/>Il concetto di grafo</a></li></ul><div class=card-footer><a class="btn btn-primary" href=https://profschimd.github.io/materie/inf/4/04-grafi-alberi/>Index</a></div></div></nav></main></div><div class="py-3 border-top bg-light mt-auto"><div class=container><div class=row><div class=col-sm><ul class=list-unstyled><li>Michele Schimd &copy; 2022</li><li><a class=pr-1 href=mailto:michele.schimd@itiszuccante.edu.it><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-at" viewBox="0 0 16 16"><path d="M.05 3.555A2 2 0 012 2h12a2 2 0 011.95 1.555L8 8.414.05 3.555zM0 4.697v7.104l5.803-3.558L0 4.697zM6.761 8.83.191 12.857A2 2 0 002 14h12a2 2 0 001.808-1.144l-6.57-4.027L8 9.586l-1.239-.757zm3.436-.586L16 11.801V4.697l-5.803 3.546z"/></svg></a><a class=pr-1 rel=me href=https://github.com/ProfSchimd target=_blank title=ProfSchimd alt=GitHub><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-github" viewBox="0 0 16 16"><path d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.012 8.012.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><a class=pr-1 rel=me href=https://www.linkedin.com/in/michele-schimd-44a85160 target=_blank title=michele-schimd-44a85160 alt=Linkedin><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-linkedin" viewBox="0 0 16 16"><path d="M0 1.146C0 .513.526.0 1.175.0h13.65C15.474.0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487.0 14.854V1.146zm4.943 12.248V6.169H2.542v7.225h2.401zm-1.2-8.212c.837.0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248-.822.0-1.359.54-1.359 1.248.0.694.521 1.248 1.327 1.248h.016zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869.0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274.0-1.845.7-2.165 1.193v.025h-.016a5.54 5.54.0 01.016-.025V6.169h-2.4c.03.678.0 7.225.0 7.225h2.4z"/></svg></a><a class=pr-1 rel=me href=https://stackoverflow.com/users/18081937 target=_blank title=18081937><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-stack-overflow" viewBox="0 0 16 16"><path d="M12.412 14.572V10.29h1.428V16H1v-5.71h1.428v4.282h9.984z"/><path d="M3.857 13.145h7.137v-1.428H3.857v1.428zM10.254.0 9.108.852l4.26 5.727 1.146-.852L10.254.0zm-3.54 3.377 5.484 4.567.913-1.097L7.627 2.28l-.914 1.097zM4.922 6.55l6.47 3.013.603-1.294-6.47-3.013-.603 1.294zm-.925 3.344 6.985 1.469.294-1.398-6.985-1.468-.294 1.397z"/></svg></a></li><li><span style=font-size:small><em>Ultimo aggiornamento: 15/12/2022</em></span></li></ul></div><div class="col-lg text-right"><ul class=list-unstyled><li>Materiale di studio e di esercizio per gli alunni dello Zuccante.</li></ul><div><p><a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/><img style=float:right alt="Creative Commons License" src=https://i.creativecommons.org/l/by-nc/4.0/88x31.png></a></div></p></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js integrity=sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js integrity=sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF crossorigin=anonymous></script></body></html>