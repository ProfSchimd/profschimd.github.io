<!doctype html><html><head><meta charset=utf-8><title>Dart stream &ndash; Michele Schimd</title><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://cdn.jsdelivr.net/npm/bootswatch@4.5.2/dist/spacelab/bootstrap.min.css rel=stylesheet><link href=https://profschimd.github.io/css/syntax.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css><script src=https://code.jquery.com/jquery-3.4.1.slim.min.js integrity=sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n crossorigin=anonymous></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class="d-flex flex-column min-vh-100"><header><nav class="p-1 navbar navbar-expand-lg navbar-dark bg-primary"><div class=container><a class=navbar-brand rel=author href=https://profschimd.github.io/>Michele Schimd</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav ml-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-expanded=false>Materie</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a href=https://profschimd.github.io/materie/inf/ class=dropdown-item>Informatica</a></li><li><a href=https://profschimd.github.io/materie/sr/ class=dropdown-item>SR</a></li><li><a href=https://profschimd.github.io/materie/tpsit/ class=dropdown-item>TPSIT</a></li><li><a href=https://profschimd.github.io/materie/gpoi/ class=dropdown-item>GPOI</a></li><li><a href=https://profschimd.github.io/materie/ec/ class=dropdown-item>EC</a></li><li><a href=https://profschimd.github.io/materie/python/ class=dropdown-item>Python</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-expanded=false>Classi</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a href=https://profschimd.github.io/classi/4ia/ class=dropdown-item>4IA</a></li><li><a href=https://profschimd.github.io/classi/4ic/ class=dropdown-item>4IC</a></li><li><a href=https://profschimd.github.io/classi/5ic/ class=dropdown-item>5IC</a></li><li><a href=https://profschimd.github.io/classi/5id/ class=dropdown-item>5ID</a></li><li><a href=https://profschimd.github.io/classi/anni-passati/ class=dropdown-item>Anni precedenti</a></li></ul></li><li class=nav-item><a class=nav-link href=https://profschimd.github.io/about/ role=button><i class="bi bi-info-circle"></i></a></li></ul></div></div></nav></header><div class="p-4 bg-primary" style="background-size:cover;background-position:50%;background-image:linear-gradient(to bottom,rgba(0,0,0,.3) 0%,rgba(0,0,0,.6) 100%),url(https://profschimd.github.io/img/zuccante_it.jpeg)"><div class=container><h1 class="display-4 text-white">Dart stream</h1></div></div><div class=bg-light><nav aria-label="breadcrumb mt-0"><div class=container><ol class=breadcrumb><li class=breadcrumb-item><a href=https://profschimd.github.io/>Home</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/>Materie</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/tpsit/>TPSIT</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/tpsit/5/>Quinto Anno</a></li><li class=breadcrumb-item><a href=https://profschimd.github.io/materie/tpsit/5/02-asynch/>Programmazione asincrona in Dart</a></li><li class="breadcrumb-item active" aria-current=page><a href=https://profschimd.github.io/materie/tpsit/5/02-asynch/02-stream-dart/>Dart stream</a></li></ol></nav></div><div class="container py-5"><main><div class=row><div class=col-10><aside><nav id=TableOfContents><ul><li><a href=#cosa-sono-gli-stream>Cosa sono gli stream</a></li><li><a href=#utilizzare-stream>Utilizzare stream</a></li><li><a href=#creare-stream>Creare stream</a><ul><li><a href=#creazione-di-uno-stream-con-async>Creazione di uno stream con <code>async*</code></a></li><li><a href=#creazione-di-uno-stream-a-partire-da-un-altro-stream>Creazione di uno stream a partire da un altro stream</a></li></ul></li><li><a href=#link-utili>Link utili</a></li></ul></nav></aside></div><div class=col-2><a class="btn btn-outline-primary my-1 w-100" href=https://github.com/ProfSchimd/teaching-material/tree/main/tpsit/dart/async role=button target=_blank><i class="bi bi-github"></i> Source</a></div></div><article><div class=container style=text-align:justify><p>In questa lezione impareremo:</p><ol><li>cosa sono gli stream in Dart e come si utilizzano,</li><li>come creare uno stream con <code>async*</code> e</li><li>come creare stream a partire da altri stream.</li></ol><h2 id=cosa-sono-gli-stream>Cosa sono gli stream</h2><p>In Dart con il termine <strong>stream</strong> ci si riferisce a dei *generatori di eventi
<em>asincroni</em>, si può pensare ad uno stream come ad una sequenza di <code>Future</code> (vedi
<a href=https://profschimd.github.io/materie/tpsit/5/02-asynch/01-dart-async-await/>lezioni su <code>async</code> e <code>await</code></a>).</p><div class="alert alert-danger" markdown=1><h5 class="alert-danger no_toc"><i class="bi bi-exclamation-triangle"></i> Attenzione</strong></h5><p>In diversi linguaggi di programmazione (ad esempio Java e C++) il concetto di
<em>stream</em> viene utilizzato per indicare un flusso di dati. Anche in Dart gli
stream rappresentano un flusso di dati, ma questo flusso obbedisce alle regole
della programmazione asincrona.</p></div><p>Nel resto della lezione vedremo, prima come si utilizza uno stream, poi come si
crea.</p><h2 id=utilizzare-stream>Utilizzare stream</h2><p>Per comprendere come utilizzare uno stream, consideriamo l&rsquo;esempio proposta anche
nella <a href=https://dart.dev/tutorials/language/streams target=_blank rel=noopener>documentazione Dart sull&rsquo;utilizzo degli stream</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>sumStream</span><span class=p>(</span><span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>stream</span><span class=p>)</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=n>sum</span> <span class=o>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>await</span> <span class=k>for</span> <span class=p>(</span><span class=kd>final</span> <span class=n>value</span> <span class=k>in</span> <span class=n>stream</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sum</span> <span class=o>+=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Avendo completato le <a href=https://profschimd.github.io/materie/tpsit/5/02-asynch/01-dart-async-await/>lezione su <code>async</code> e <code>await</code></a>,
l&rsquo;intera funzione <code>sumStream</code> dovrebbe essere chiara ad eccezione del costrutto <code>await for</code>.
Il miglior modo per capire il funzionamento di <code>await for</code> è di immaginarlo come un normale
<em>for each</em> nel quale ogni iterazione del ciclo è una chiamata asincrona con <code>await</code>.</p><p>Vediamo quindi cosa succede in dettaglio alla chiamata della funzione <code>sumStream</code> (si noti
come tale chiamata avviene mediante <code>await</code>, infatti <code>sumStream</code> è una funzione <code>async</code>).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=kd>await</span> <span class=n>sumStream</span><span class=p>(</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li>Quando il <code>main</code> invoca la funzione asincrona <code>sumStream</code>, la funziona viene
eseguita normalmente fino alla riga contenente <code>await for</code>.</li><li>Quando viene incontrata l&rsquo;istruzione <code>await for</code>, Dart inizia ad iterare
sull&rsquo;oggetto <code>stream</code>, esattamente come un normale <em>for each</em>, la differenza è
che ogni volta che si assegna a <code>value</code> il prossimo valore, questo assegnamento
è come una chiamata asincrona a <code>stream</code>.</li><li>La chiamata <code>await for</code> &ldquo;attiva&rdquo; lo stream che inizia a generare eventi
asincroni (sulla base di come lo stream è stato creato, <a href=#creare-stream>vedi sotto</a>.</li><li>Ogni evento asincrono generato dallo stream mette in <code>await</code> la funzione <code>sumStream</code>
esattamente come se fosse una singola chiamata <code>await</code>.</li><li>Quando lo stream ha terminato di generare eventi, l&rsquo;istruzione <code>await for</code>
termina esattamente come termina un <em>for each</em> quando tutti gli elementi dell&rsquo;<code>Iterable</code>
sono stati considerati.</li></ol><div class="alert alert-warning" markdown=1><h5 class=no_toc><i class="bi bi-exclamation-octagon"></i> Importante</h5><p>La funzione <code>sumStream</code> deve essere <code>async</code> per poter utilizzare <code>await for</code>
(esattamente come ogni funzione che usa <code>await</code> deve essere <code>async</code>). Essendo una
funzione <code>async</code>, quindi, <code>sumStream</code> restituisce un <code>Future</code> (in questo caso di
tipo <code>int</code>). Come visto nella <a href=https://profschimd.github.io/materie/tpsit/5/02-asynch/01-dart-async-await/ target=_blank rel=noopener>lezione <code>await</code> <code>async</code></a>,
la chiamata ad una funzione <code>async</code> può o meno avvenire con <code>await</code>, ma nel caso
si ometta, la variabile restituita (immediatamente senza attendere la terminazione)
è di tipo <code>Future&lt;int></code> anziché di tipo <code>int</code>.</p></div><h2 id=creare-stream>Creare stream</h2><p>Per creare uno stream ci sono 3 modi:</p><ol><li>definire una funzione <code>async*</code>,</li><li>generare uno stream a partire da un altro stream e</li><li>usare la classe <code>StreamController</code>.</li></ol><p>In questa lezione ci occupiamo solo dei primi due casi, per maggiori dettagli
anche sull&rsquo;uso di <code>StreamController</code> si può consultare la <a href=https://dart.dev/articles/libraries/creating-streams target=_blank rel=noopener>documentazione online
sulla creazione di stream</a>.</p><h3 id=creazione-di-uno-stream-con-async>Creazione di uno stream con <code>async*</code></h3><p>Anche in questa parte della lezione utilizziamo lo stesso esempio della <a href=https://dart.dev/articles/libraries/creating-streams target=_blank rel=noopener>guida online</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>timedCounter</span><span class=p>(</span><span class=n>Duration</span> <span class=n>interval</span><span class=p>,</span> <span class=p>[</span><span class=kt>int</span><span class=o>?</span> <span class=n>maxCount</span><span class=p>])</span> <span class=kd>async</span><span class=o>*</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>await</span> <span class=n>Future</span><span class=p>.</span><span class=n>delayed</span><span class=p>(</span><span class=n>interval</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kd>yield</span> <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>maxCount</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>La funzione <code>timedCounter</code> sotto crea uno <code>Stream&lt;int></code> che conta fino a <code>maxCount-1</code>
(o all&rsquo;infinito), il conteggio avviene ad intervalli regolari di durata `interval.</p><p>Come si nota, la funzione <code>timedCounter</code> utilizza due costrutti propri della programmazione
asincrona <code>await</code> e <code>yield</code>. L&rsquo;uso di <code>await</code> in questo caso serve unicamente a far
trascorrere l&rsquo;intervallo di tempo richiesto, infatti il risultato della
chiamata <code>Future.delayed</code> non viene mai utilizzato (tanto che non viene nemmeno
memorizzato).</p><p>L&rsquo;utilizzo di <code>yield</code> necessita di una breve spiegazione, ogni volta che uno stream
deve <em>emettere</em> un nuovo valore, lo fa attraverso la parola chiave <code>yield</code>. Nell&rsquo;esempio
sopra ogni secondo viene emesso il valore della variabile <code>i</code> che successivamente viene
incrementato (ricorda la semantica di <code>i++</code> e di <code>++i</code>).</p><div class="alert alert-warning" markdown=1><h5 class=no_toc><i class="bi bi-exclamation-octagon"></i> Importante</h5><p>La funzione <code>timedCounter</code> sopra è stata dichiarata <em>asincrona star</em> con la parola
chiave <code>async*</code>, questa significa che questa funzione restituisce uno <code>Stream</code> esattamente
come <code>async</code> (senza <code>*</code>) significa che la funzione restituisce un <code>Future</code>.</p></div><p>Per vedere un esempio di utilizzo di <code>timedCounter</code>, consideriamo il seguente
codice che stampa a video il conteggio dei secondi da <code>0</code> a <code>9</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>timedCounter</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>seconds:</span> <span class=m>1</span><span class=p>),</span> <span class=m>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kd>await</span> <span class=k>for</span> <span class=p>(</span><span class=kd>final</span> <span class=n>i</span> <span class=k>in</span> <span class=n>stream</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>$</span><span class=n>i</span><span class=s1> seconds&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class="alert alert-primary" markdown=1><h5 class=no_toc><i class="bi bi-pencil-square"></i> Esercizio</strong></h5><p>Spesso è utile avere un <em>countdown</em> cioè un conteggio dal valore iniziale a <code>0</code>,
scrivere una funzione <code>timedCountdown</code> con gli stessi parametri di <code>timedCounter</code>
che restituisca uno stream per il <em>countdown</em>.</p></div><h3 id=creazione-di-uno-stream-a-partire-da-un-altro-stream>Creazione di uno stream a partire da un altro stream</h3><p>Spesso si vuole generare uno stream a partire da un altro stream, ad esempio
uno stream che generare un evento ogni secondo lo vogliamo trasformare in uno
che genera un evento ogni 5 secondi, oppure da una sequenza di stringhe vogliamo
estrarre solo quelle che iniziano con una specifica parola.</p><p>Un modo ovvio per fare questa operazione di <em>trasformazione</em> è definendo una
funzione <code>async*</code> che prende lo stream originale come input e genera gli eventi
&ldquo;trasformati&rdquo;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>squaredCounter</span><span class=p>(</span><span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>counter</span><span class=p>)</span> <span class=kd>async</span><span class=o>*</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>await</span> <span class=k>for</span> <span class=p>(</span><span class=kd>final</span> <span class=n>i</span> <span class=k>in</span> <span class=n>counter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>yield</span> <span class=n>i</span><span class=o>*</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=metodi-di-stream>Metodi di <code>Stream</code></h4><p>Il secondo modo per &ldquo;trasformare&rdquo; uno stream in un altro è attraverso dei metodi
specifici forniti dalla <a href=https://api.dart.dev/stable/2.18.4/dart-async/Stream-class.html target=_blank rel=noopener>classe <code>Stream</code></a>. La lista di questi metodi è troppo
lunga per essere discussa qui per esteso, ma possiamo vederne alcuni tra i più
comunemente utilizzati.</p><ul><li><code>map</code>: converte ogni elemento dello stream originale in un nuovo evento</li><li><code>skip</code>: salta il numero di eventi indicato</li><li><code>take</code>: prende il numero di eventi indicato</li><li><code>where</code>: seleziona solo gli eventi con soddisfano la condizione data</li></ul><p>Nell&rsquo;esempio sotto vediamo l&rsquo;utilizzo di questi metodi questi metodi</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=c1>// map: trasforma &#39;i&#39; in &#39;i*i&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>timedCounter</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>milliseconds:</span> <span class=m>200</span><span class=p>),</span> <span class=m>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>transformed</span> <span class=o>=</span> <span class=n>stream</span><span class=p>.</span><span class=n>map</span><span class=p>((</span><span class=n>i</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=n>i</span><span class=o>*</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>await</span> <span class=k>for</span> <span class=p>(</span><span class=kd>final</span> <span class=n>i</span> <span class=k>in</span> <span class=n>transformed</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// 0, 1, 4, 16
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// take: prende i primi &#39;3&#39; elementi dello stream
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stream</span> <span class=o>=</span> <span class=n>timedCounter</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>milliseconds:</span> <span class=m>200</span><span class=p>),</span> <span class=m>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>transformed</span> <span class=o>=</span> <span class=n>stream</span><span class=p>.</span><span class=n>take</span><span class=p>(</span><span class=m>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>await</span> <span class=k>for</span> <span class=p>(</span><span class=kd>final</span> <span class=n>i</span> <span class=k>in</span> <span class=n>transformed</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// 0, 1, 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// skip: salta i primi &#39;3&#39; elemento dello stream
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stream</span> <span class=o>=</span> <span class=n>timedCounter</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>milliseconds:</span> <span class=m>200</span><span class=p>),</span> <span class=m>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>transformed</span> <span class=o>=</span> <span class=n>stream</span><span class=p>.</span><span class=n>skip</span><span class=p>(</span><span class=m>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>await</span> <span class=k>for</span> <span class=p>(</span><span class=kd>final</span> <span class=n>i</span> <span class=k>in</span> <span class=n>transformed</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// 3, 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// where: considera solo gli elementi pari (i%2 == 0) dello stream
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stream</span> <span class=o>=</span> <span class=n>timedCounter</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>milliseconds:</span> <span class=m>200</span><span class=p>),</span> <span class=m>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>transformed</span> <span class=o>=</span> <span class=n>stream</span><span class=p>.</span><span class=n>where</span><span class=p>((</span><span class=n>i</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=m>2</span> <span class=o>==</span> <span class=m>0</span><span class=p>));</span> <span class=c1>// numeri pari
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>await</span> <span class=k>for</span> <span class=p>(</span><span class=kd>final</span> <span class=n>i</span> <span class=k>in</span> <span class=n>transformed</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// 0, 2, 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><div class="alert alert-danger" markdown=1><h5 class="alert-danger no_toc"><i class="bi bi-exclamation-triangle"></i> Attenzione</strong></h5><p><p>Affinché uno stream possa generare eventi a partire da un stream di origine,
quest&rsquo;ultimo deve essere utilizzabile nel senso che non deve essere terminato.
L&rsquo;utilizzo di uno stream ormai concluso genera un errore con un messaggio
simile al seguente:</p><pre><code>Uncaught Error: Bad state: Stream has already been listened to.
</code></pre></p></div><div class="alert alert-danger" markdown=1><h5 class="alert-danger no_toc"><i class="bi bi-exclamation-triangle"></i> Attenzione</strong></h5><p><p>L&rsquo;utilizzo delle funzioni di trasformazione quali <code>map</code>, <code>where</code>, &mldr;
&ldquo;consumano&rdquo; lo stream originale. Per questo motivo, dopo aver consumato lo
stream trasformato, anche lo stream originale sarà concluso e diventa un
errore usare <code>await for</code> su quello stream.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=kd>async</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>timedCounter</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>milliseconds:</span> <span class=m>200</span><span class=p>),</span> <span class=m>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>transformed</span> <span class=o>=</span> <span class=n>stream</span><span class=p>.</span><span class=n>map</span><span class=p>((</span><span class=n>i</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=n>i</span><span class=o>*</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kd>await</span> <span class=k>for</span> <span class=p>(</span><span class=kd>final</span> <span class=n>i</span> <span class=k>in</span> <span class=n>transformed</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// 0, 1, 4, 9, 16, ... 81
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Error: &#39;already listened&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>await</span> <span class=k>for</span> <span class=p>(</span><span class=kd>final</span> <span class=n>i</span> <span class=k>in</span> <span class=n>stream</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></p></div><h4 id=utilizzo-di-foreach>Utilizzo di <code>forEach</code></h4><p>Nella classe <code>Stream</code> è disponibile il metodo <code>forEach</code> che restituisce un <code>Future</code>,
questo metodo può essere utilizzato al posto di <code>await for</code> per generare codice
più compatto (soprattutto se l&rsquo;operazione da fare nel corpo del <code>for</code> è semplice
come un semplice <code>print(i)</code>). Ad esempio il codice sotto è equivalente all&rsquo;utilizzo
di <code>where</code> visto sopra per stampare i soli numeri pari</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>timedCounter</span><span class=p>(</span><span class=n>Duration</span><span class=p>(</span><span class=nl>milliseconds:</span> <span class=m>200</span><span class=p>),</span> <span class=m>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>stream</span><span class=p>.</span><span class=n>where</span><span class=p>((</span><span class=n>i</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=m>2</span> <span class=o>==</span> <span class=m>0</span><span class=p>)).</span><span class=n>forEach</span><span class=p>(</span><span class=n>print</span><span class=p>);</span>
</span></span></code></pre></div><p>Si noti che:</p><ul><li>si usa lo <code>Stream</code> restituito da <code>where</code> in modo implicito (senza assegnarlo) ad
una variabile,</li><li>il metodo <code>forEach</code> accetta una funzione con un parametro che è l&rsquo;evento emesso
dal stream, in questo esempio la funzione è <code>print</code></li></ul><h2 id=link-utili>Link utili</h2><ul><li><a href=https://dart.dev/tutorials/language/streams target=_blank rel=noopener>Utilizzare stream (English)</a></li><li><a href=https://dart.dev/articles/libraries/creating-streams target=_blank rel=noopener>Creare stream (English)</a></li><li><a href=https://dart.dev/guides/language/language-tour#handling-streams target=_blank rel=noopener>Introduzione stream nel &ldquo;Dart Language Tour&rdquo; (English)</a></li></ul></div></article><nav class="mx-5 my-3"><div class=card><h5 class=card-header>Indice di Programmazione asincrona in Dart</h5><ul class="list-group list-group-flush"><li class=list-group-item><a href=https://profschimd.github.io/materie/tpsit/5/02-asynch/01-dart-async-await/>Dart async e await</a></li><li class="list-group-item list-group-item-primary"><strong><a href=https://profschimd.github.io/materie/tpsit/5/02-asynch/02-stream-dart/>> Dart stream</a></strong></li><li class=list-group-item><a href=https://profschimd.github.io/materie/tpsit/5/02-asynch/l01-async-http/>Laboratorio: richiesta HTTP con async</a></li></ul><div class=card-footer><a class="btn btn-primary" href=https://profschimd.github.io/materie/tpsit/5/02-asynch/>Index</a></div></div></nav></main></div><div class="py-3 border-top bg-light mt-auto"><div class=container><div class=row><div class=col-sm><ul class=list-unstyled><li>Michele Schimd &copy; 2023</li><li><a class=pr-1 href=mailto:michele.schimd@itiszuccante.edu.it><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-at" viewBox="0 0 16 16"><path d="M.05 3.555A2 2 0 012 2h12a2 2 0 011.95 1.555L8 8.414.05 3.555zM0 4.697v7.104l5.803-3.558L0 4.697zM6.761 8.83.191 12.857A2 2 0 002 14h12a2 2 0 001.808-1.144l-6.57-4.027L8 9.586l-1.239-.757zm3.436-.586L16 11.801V4.697l-5.803 3.546z"/></svg></a><a class=pr-1 rel=me href=https://github.com/ProfSchimd target=_blank title=ProfSchimd alt=GitHub><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-github" viewBox="0 0 16 16"><path d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.012 8.012.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><a class=pr-1 rel=me href=https://www.linkedin.com/in/michele-schimd-44a85160 target=_blank title=michele-schimd-44a85160 alt=Linkedin><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-linkedin" viewBox="0 0 16 16"><path d="M0 1.146C0 .513.526.0 1.175.0h13.65C15.474.0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487.0 14.854V1.146zm4.943 12.248V6.169H2.542v7.225h2.401zm-1.2-8.212c.837.0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248-.822.0-1.359.54-1.359 1.248.0.694.521 1.248 1.327 1.248h.016zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869.0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274.0-1.845.7-2.165 1.193v.025h-.016a5.54 5.54.0 01.016-.025V6.169h-2.4c.03.678.0 7.225.0 7.225h2.4z"/></svg></a><a class=pr-1 rel=me href=https://stackoverflow.com/users/18081937 target=_blank title=18081937><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" fill="currentcolor" class="bi bi-stack-overflow" viewBox="0 0 16 16"><path d="M12.412 14.572V10.29h1.428V16H1v-5.71h1.428v4.282h9.984z"/><path d="M3.857 13.145h7.137v-1.428H3.857v1.428zM10.254.0 9.108.852l4.26 5.727 1.146-.852L10.254.0zm-3.54 3.377 5.484 4.567.913-1.097L7.627 2.28l-.914 1.097zM4.922 6.55l6.47 3.013.603-1.294-6.47-3.013-.603 1.294zm-.925 3.344 6.985 1.469.294-1.398-6.985-1.468-.294 1.397z"/></svg></a></li><li><span style=font-size:small><em>Ultimo aggiornamento: 27/02/2023</em></span></li></ul></div><div class="col-lg text-right"><ul class=list-unstyled><li>Materiale di studio e di esercizio per gli alunni dello Zuccante.</li></ul><div><p><a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/><img style=float:right alt="Creative Commons License" src=https://i.creativecommons.org/l/by-nc/4.0/88x31.png></a></div></p></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js integrity=sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js integrity=sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF crossorigin=anonymous></script></body></html>