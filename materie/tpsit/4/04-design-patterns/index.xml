<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design Patterns on Michele Schimd</title><link>https://profschimd.github.io/materie/tpsit/4/04-design-patterns/</link><description>Recent content in Design Patterns on Michele Schimd</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://profschimd.github.io/materie/tpsit/4/04-design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduzione ai Design Pattern</title><link>https://profschimd.github.io/materie/tpsit/4/04-design-patterns/00-intro-design-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://profschimd.github.io/materie/tpsit/4/04-design-patterns/00-intro-design-pattern/</guid><description>In questa lezione si presentano i design pattern che vengono affrontati in questo modulo. Pur non rappresentando una lista esaustiva, i pattern qui menzionati (trattati in dettaglio nelle seguenti lezioni) coprono un significativo numero di situazioni di progettazione software.</description></item><item><title>Creational Patterns</title><link>https://profschimd.github.io/materie/tpsit/4/04-design-patterns/01-creational-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://profschimd.github.io/materie/tpsit/4/04-design-patterns/01-creational-patterns/</guid><description>I creational patterns sono design patterns che vengono utilizzati per la creazione (factoring) di istanze tipicamente per astrarre l&amp;rsquo;accesso al costruttore.</description></item><item><title>Structural Patterns</title><link>https://profschimd.github.io/materie/tpsit/4/04-design-patterns/02-structural-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://profschimd.github.io/materie/tpsit/4/04-design-patterns/02-structural-patterns/</guid><description>Adapter Il pattern Adapter prevede che una classe o interfaccia venga utilizzata per adattare due interfacce &amp;ldquo;incompatibili&amp;rdquo;. Un caso molto comune di utilizzo dell&amp;rsquo;adapter è quando si decide (o si deve) utilizzare una classe di &amp;ldquo;libreria&amp;rdquo; la cui interfaccia non è compatibile con il codice già scritto.
Supponiamo che un software gestionale acceda ai dati mediante un database e che per fare questo usi una libreria con i seguenti metodi</description></item><item><title>Behavioral Patterns</title><link>https://profschimd.github.io/materie/tpsit/4/04-design-patterns/03-behavioral-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://profschimd.github.io/materie/tpsit/4/04-design-patterns/03-behavioral-patterns/</guid><description>Iterator L&amp;rsquo;iterator pattern prevede che si realizzi un meccanismo per accedere, in modo sequenziale, agli elementi di una collezione, senza che i dettagli circ la memorizzazione di tali elementi siano noti (o debbano servire per l&amp;rsquo;accesso).
Ad oggi un meccanismo basato su iterator è presente in pressoché tutti i linguaggi, spesso realizzati da funzioni o classi di libreria. Prima di passare all&amp;rsquo;implementazione di un iterator, vediamo come utilizzarne uno già presente nella libreria Java.</description></item></channel></rss>