<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sincronizzazione on Michele Schimd</title><link>https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/</link><description>Recent content in Sincronizzazione on Michele Schimd</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/index.xml" rel="self" type="application/rss+xml"/><item><title>Sincronizzazione</title><link>https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/sincronizzazione/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/sincronizzazione/</guid><description>Cos&amp;rsquo;è la sincronizzazione Vari tipi di problemi hanno soluzioni le cui operazioni devono essere fatte in un ordine ben preciso. Ad esempio, quando si cucina una pizza, si deve aspettare che il forno sia caldo prima che si possa inserire la pizza cruda. Inoltre, gli ingredienti devono essere messi prima di infornare la pizza altrimenti questi non si cuociono.
Anche nei problemi informatici è spesso necessario che le operazioni si svolgano in una sequenza ben precisa, questa sequenza di operazione prende il nome di algoritmo.</description></item><item><title>Sezione critica</title><link>https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/sezione_critica/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/sezione_critica/</guid><description>Il problema della sezione critica Un sistema multithread può presentare problemi di sincronizzazione dovuti all&amp;rsquo;utilizzo da parte di due o più thread della stessa risorsa. Questa risorsa può essere un file e perfino una variabile (ricordiamo che i thread di un processo lavorano su uno spazio di memoria condiviso, quindi possono usare variabili condivise). Un esempio di questi problemi di sincronizzazione si ha in caso di race condition (come descritto qui).</description></item><item><title>Mutex, Semafori e Monitor</title><link>https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/mutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/mutex/</guid><description>Mutex Il concetto di Mutex (Mutual Exclusive) viene usato per indicare una qualche risorsa che può essere utilizzata da un solo thread o processo per volta
Osserva Si dice quindi che l&amp;rsquo;uso da parte un thread esclude l&amp;rsquo;uso da tutti gli altri da cui la dicitura mutua esclusione.
In pratica, un mutex è una variabile bool, quindi che può assumere solo i valor true e false. Quando la variabile è true il mutex è stato acquisito da un qualche thread ed è quindi locked.</description></item><item><title>Deadlock</title><link>https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/deadlock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://profschimd.github.io/materie/tpsit/4/02-sincronizzazione/deadlock/</guid><description>La sincronizzazione è una tecnica che permette di fissare l&amp;rsquo;ordine di esecuzione di thread. Con la sincronizzazione è possibile, quindi, imporre delle regole del tipo il thread A deve finire prima del thread B oppure il thread C deve partire quando i thread D, E ed F sono terminati. Di conseguenza le tecniche di sincronizzazione sono molto utili e vengono spesso usate nella programmazione concorrente. Tuttavia l&amp;rsquo;utilizzo della sincronizzazione può avere anche effetti negativi, a volte &amp;ldquo;gravi&amp;rdquo;, come quello del deadlock che discutiamo qui sotto.</description></item></channel></rss>